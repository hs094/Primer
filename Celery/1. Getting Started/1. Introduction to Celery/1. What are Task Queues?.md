These are used as a mechanism to distribute tasks across workers. (Threads, Machines)

Celery communicates via messages, usually using a broker to mediate between clients and workers. To initiate a task the client adds a message to the queue, the broker then delivers that message to a worker.

A Celery system can consist of multiple workers and brokers, giving way to high availability and horizontal scaling.

Language interoperability can also be achieved exposing an HTTP endpoint and having a task that requests it (webhooks).

## What do I need

_Celery_ requires a message transport to send and receive messages. The _RabbitMQ_ and _Redis_ broker transports are feature complete, but there’s also support for a myriad of other experimental solutions, including using SQLite for local development.

_Celery_ can run on a single machine, on multiple machines, or even across data centers.

![[Pasted image 20251211141510.png]]

## Features
* **Monitoring:** A stream of monitoring events is emitted by workers and is used by built-in and external tools to tell you what your cluster is doing – in real-time.
* **Work-flows:**  Simple and complex work-flows can be composed using a set of powerful primitives we call the “canvas”, including grouping, chaining, chunking, and more.
* **Time and Rate Limits:** You can control how many tasks can be executed per second/minute/hour, or how long a task can be allowed to run, and this can be set as a default, for a specific worker or individually for each task type.
* **Scheduling:** You can specify the time to run a task in seconds or a [`datetime`](https://docs.python.org/dev/library/datetime.html#datetime.datetime "(in Python v3.15)"), or you can use periodic tasks for recurring events based on a simple interval, or Crontab expressions supporting minute, hour, day of week, day of month, and month of year.
* 